{
    "contents" : "hotdogs <- read.csv(\"http://datasets.flowingdata.com/hot-dog-contest-winners.csv\")\nhead(hotdogs)\n## Year : 년도 , Winner : 우승자명 , Dogs.eaten : 먹은 개수, Country : 나라 이름\n# Year                       Winner Dogs.eaten       Country New.record\n# 1980 Paul Siederman & Joe Baldini       9.10 United States          0\n# 1981              Thomas DeBerry       11.00 United States          0\n# 1982               Steven Abrams       11.00 United States          0\n# 1983                 Luis Llamas       19.50        Mexico          0\n# 1984               Birgit Felden        9.50       Germany          0\n# 1985             Oscar Rodriguez       11.75 United States          0\nstr(hotdogs)\n# data.frame':\t31 obs. of  5 variables:\n# $ Year      : int  1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 ...\n# $ Winner    : Factor w/ 18 levels \"Birgit Felden \",..: 13 18 15 9 1 12 10 2 6 6 ...\n# $ Dogs.eaten: num  9.1 11 11 19.5 9.5 ...\n# $ Country   : Factor w/ 4 levels \"Germany\",\"Japan\",..: 4 4 4 3 1 4 4 4 4 4 ...\n# $ New.record: int  0 0 0 0 0 0 0 0 0 0 ...\nsummary(hotdogs)\ncolors = rep(\"grey\", 31) ## 색깔 반복 지정(변수 개수 만큼)\ncolors[new.record==TRUE] = \"blue\" ## 미국은 회색으로 지정\n## barplot(y축, names.arg = x축값 , xlab  = x축 이름 , ylab = y축 이름, main = 그래프의 제목, ylim = y축의 범위 변경 , xlim = x축의 범위 변경)\nbp <- barplot(hotdogs$Dogs.eaten, names.arg = hotdogs$Year, col=colors, border=NA, xlab=\"Year\", ylab=\"Hot dogs and buns (HDB) eaten\", main=\"Nathan's Hot Dog Eating Contest Results, 1980-2010\", ylim= c(0,70))\n## legend(배치위치 ,legend = 레전드명, fill = 넣을 색 지정, border = 선,title = 레전드의 제목)\nlegend(\"topleft\", legend=c(\"United States\", \"Others\"), fill=c(\"grey\", \"blue\"), border=NA, title=\"winner's Nationality\")\n# hotdogs[hotdogs$New.record == 1,]\n# x축의 위치를 찾기 위해선 barplot을 변수처리르 통해 처리 가능(http://www.ats.ucla.edu/stat/r/faq/barplotplus.htm)\ntext(bp[new.record], hotdogs$Dogs.eaten[new.record]+1, hotdogs$Dogs.eaten[new.record], cex=0.7)\n\neaten.max = c(); eaten.max[1] = hotdogs$Dogs.eaten[1]\nfor (i in 2:31) {\n  eaten.max[i] = max(hotdogs$Dogs.eaten[1:(i-1)])\n  \n}\n\neaten.max\nnew.record = eaten.max<hotdogs$Dogs.eaten\n\n# check.names : 숫자앞에 X 빼기\nhotdog_places <- read.csv(\"http://datasets.flowingdata.com/hot-dog-places.csv\", check.names = FALSE)\n\nhead(hotdog_places)\n#   2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010\n# 1   25 50.0 50.5 44.5 53.5   49   54   66   59 68.0   54\n# 2   24 31.0 26.0 30.5 38.0   37   52   63   59 64.5   43\n# 3   22 23.5 25.5 29.5 32.0   32   37   49   42 55.0   37\n\n## matrix 변경\nhotdog_places <- as.matrix(hotdog_places)\n## 자동으로 쌓아서 보여줌\nbarplot(hotdog_places, beside=T)\n## year 두자리로 변수 생성\nyears <- paste(\"'\", substr(colnames(hotdog_places), 3,4), sep=\"\")\n\nbarplot(hotdog_places, names.arg = years)\n\n#################################### practice 1 #############################################\nlibrary(XLConnect)\nlibrary(plyr)\ninstall.packages(\"reshape\")\nlibrary(reshape)\n\ndata <- read.csv(\"OctagonExcel.csv\", check.names = FALSE)\nrownames(data) <- data[,1]\ndata <- data[,-1]\ndata <- as.matrix(data)\n\n\nyears_pr <- paste(\"'\", substr(colnames(data), 3,4), sep=\"\")\nyears_pr\n\nbarplot(data, names.arg = years_pr, col=1:5) ## 전체적으로 이혼건수가 감소 - 결혼하는 수가 적기 때문인 듯?\nlegend(\"topright\", legend=rownames(data), fill=c(1:5), border=NA, title=\"결혼년수\")\n\nhead(data)\n#### 비율로 변환(data를 분모의 매트릭스로)\ndata_rate <- data/matrix(1,5,1) %*% apply(data, 2, sum)\n# 다 더한 값이 1인지 확인\napply(data_rate, 2, sum)\nhead(data_rate)\nbarplot(data_rate, names.arg = years_pr, col=1:5)\nlegend(\"topright\", legend=rownames(data), fill=c(1:5), border=NA, title=\"결혼년수\")\n#############################################################################################\noptions(scipen=999)\npopulation <- read.csv(\"http://datasets.flowingdata.com/world-population.csv\")\nplot(population$Year, population$Population, type=\"l\", ylim=c(0,7*10^9))\npoints(population$Year, population$Population, pch=20, xlab=\"Year\", ylab=\"Population\")\n\n######################\npostage <- read.csv(\"http://datasets.flowingdata.com/us-postage.csv\")\nhead(postage)\nstr(postage)\n\nplot(postage$Year, postage$Price, type=\"s\")\npoints(postage$Year, postage$Price, pch=20)\n\n#################### time series\nunemployment <- read.csv(\"http://datasets.flowingdata.com/unemployment-rate-1948-2010.csv\")\nhead(unemployment)\nsummary(unemployment)\n\n# install.packages(\"zoo\")\nlibrary(zoo)\n## 1~10까지 3개의 수의 평균\nrollmean(1:10,3)\n## \nrollmean(1:10, 10)\n\nma50 <- rollmean(unemployment$Value, 50)\nma5 <- rollmean(unemployment$Value, 5)\nplot(ma50, type=\"l\", ylim=c(0,10))\nlines(ma5, type=\"l\")\n\nunemployment.ts <- ts(unemployment$Value, start = c(1948,1), frequency=12)\nplot(unemployment.ts, type=\"l\", ylim=c(0,11), ylab=\"unemployment Rate\", xlab=\"Year\")\nlines(lowess(unemployment.ts), col=4, lwd=1.5)\n## f 자료의 점에서 몇분의 몇의 자료를 평활 할 것인가\nlines(lowess(unemployment.ts, f=1/3), col=2, lwd=1.5)\nlines(lowess(unemployment.ts, f=1/6), col=3, lwd=1.5)\n\n\n## 계절형 시계열 분해 \nexport <- read.table(\"Export_1988.txt\", header= T)\nhead(export)\n# time-series object 지정\nseries <- ts(export$Series/1000, start=c(1988,1), frequency=12) \nplot(series)\n\n# log 취함(변동성이 시간의 흐름에 따라 커지는 경향이 있는 경우에 취함)\n# 경제의 지표의 경우도 취함(왜냐하면 증가분이 비율로 나타나기 때문)\nlog.series <- log(series)\nplot(log.series)\n\ndecomp.out = decompose(log.series) # time-series 분해 function\nstr(decomp.out)\n# $ x       : Time-Series [1:215] from 1988 to 2006: 8.28 8.32 8.47 8.44 8.47 ... (원본자료)\n# $ seasonal: Time-Series [1:215] from 1988 to 2006: -0.1384 -0.1145 0.0347 -0.0019 0.0126 ... (계절성)\n# $ trend   : Time-Series [1:215] from 1988 to 2006: NA NA NA NA NA ... (추세성)\n# $ random  : Time-Series [1:215] from 1988 to 2006: NA NA NA NA NA ... (에러)\n# $ figure  : num [1:12] -0.1384 -0.1145 0.0347 -0.0019 0.0126 ...\n# $ type    : chr \"additive\"\n# - attr(*, \"class\")= chr \"decomposed.ts\"\n\nplot(decomp.out$trend) # 추세 패턴(계절성과 random error 를 제거)\nplot(decomp.out$seasonal) # 계절마다의 패턴\n\nplot(decomp.out$x- decomp.out$seasonal) # 검은색 선(trend와 random error를 포함한 그래프)\nlines(decomp.out$x, col=2) # 빨간선(seasonal+trend+random error가 포함)\nlines(decomp.out$trend, col=3)\n\n## 90~ 현재까지 국가별 월 수입액\nincome <- read.csv(\"income.csv\", header = T)\nhead(income)\n\nincome.ts <- ts(income$계, start = c(1990,1), frequency=12)\n\nplot(income.ts, type=\"l\", ylab=\"income\", xlab=\"Year\")\n\nlines(lowess(income.ts), col=4, lwd=1.5) # 파란색\nlines(lowess(income.ts, f=1/3), col=2, lwd=1.5) # 빨간색\nlines(lowess(income.ts, f=1/6), col=3, lwd=1.5) # 녹색\n\ntrend <- lowess(income.ts, f=1/6)\nplot(income.ts - trend$y) ## 뒤로 갈 수록 변동성이 커짐\nabline(0,0,col=2) # 선그리기(a+bx = y의 선) \n\n# log를 취함\nlog.income <- log(income.ts)\nplot(log.income)\n\n# 시계열 분해\ndecomp.income <- decompose(log.income)\nplot(decomp.income$x)\nlines(decomp.income$trend, col=2) # trend\n\n# 큰 잡음이 있는 경우는 trend나 계절성으로도 잡을 수 없는 것으로 보임\nplot(decomp.income$random) \n\nplot(decomp.income$x-decomp.income$random) # 계절성과 트렌드만 나타낸 그래프\n\n## 자기상관계수는 서로 독립이어야 함 그렇기 때문에 0이 나오는게 맞는것임. \n## 회귀분석에서의 잔차분석 시 패턴이 없이 띠 모양으로 있는 경우 괜찮은 잔차도\n## durbin-watson test : 잔차에 자기상관이 있는지 테스트\n\nlibrary(MASS)\nattach(geyser)\n\nacf(waiting)\nacf(duration)\n\n## 한번 waiting 혹은 duration이 길면 다음번은 짧음\n## 현재시점과 다음 시점의 상관계수를 확인\n## 파란점선은 정확도의 범위로 생각(이 안에 들어오게 되면 상관관계가 없다고 보면 됨)\n\n\n## 교차상관함수\n## 지금의 내 자료와 과거의 다른 자료의 상관계수를 나타냄\nccf(waiting, duration)\n## lag= 0, 지금의 분출량과 지금의 분출되기까지의 시간은 음의 상관관계\n## lag= 1, 지금의 분출량과 한시점 분출되기까지의 시간은 양의 상관관계\n\n## 임의보행(random walk)\n## 자기자신하고는 상관계수가 크지만 그 다음부터는 그 방향이 random 하게 나타나는 경우\n\n## 삼성주가\nsamsung <- read.csv(\"samsung.csv\", header=T)\nhead(samsung)\n\nplot(samsung$종가, type=\"l\")\n## 차분한 값(Yt - Yt-1 = at, Yt = Yt-1+at)\nplot(diff(samsung$종가) , type = 'l')\nacf(diff(samsung$종가)) # 차분한 값의 자기상관함수(어제의 종가와 오늘의 주가 증가 폭이 상관관계가 없음)\n\n## arima 모형의 가정은 자기상관은 시점에만 의존해야 함(정상성) -> 그렇기 때문에 자기상관함수를 통해 확인을 함.\n## 시계열 예측을 위한 모형이 arima 모형\n\n####################################### 범주형 변수 시각화 ########################################\nlibrary(RColorBrewer)\nlibrary(dplyr)\narea <- c(\"Statistics\", \"Design\", \"Business\", \"Cartography\", \"Information Science\", \"Web Analytics\", \"Programming\", \"Engineering\", \"mathmematics\", \"Others\")\nvotes <- c(172,136,135,101,80,68,50,29,19,41)\n\nnames <- paste(area,\", \",round(votes/sum(votes)*100,2),\"%\", sep=\"\")\npie(votes, labels = names, col=brewer.pal(10,\"RdGy\"))\n\nsales <- read.csv(\"sales.csv\", header = T)\nhead(sales)\n\ntab1 <- table(sales$CT1)\ntab1 <- sort(tab1, decreasing = TRUE)\n\nsales_names <- paste(names(tab1), \": \",round(tab1/sum(tab1)*100,2),\"%\", sep=\"\")\npie(tab1, labels = sales_names, col=brewer.pal(11,\"RdBu\"), main=\"카테고리 구매내역(%)\")\n\n## 2원 빈도표\n## 2개의 범주형 변수의 결합 빈도\nUCBAdmissions\nstr(UCBAdmissions)\n# table [1:2, 1:2, 1:6] 512 313 89 19 353 207 17 8 120 205 ...\n# - attr(*, \"dimnames\")=List of 3\n# ..$ Admit : chr [1:2] \"Admitted\" \"Rejected\"\n# ..$ Gender: chr [1:2] \"Male\" \"Female\"\n# ..$ Dept  : chr [1:6] \"A\" \"B\" \"C\" \"D\" ...\n\n\ntab1 <- UCBAdmissions[1,,] # Admit\ntab2 <- UCBAdmissions[2,,] # Reject\ntab <- tab1+tab2 # 총 지원자 수(Admit + Reject)\n\npar(mar=c(6.5, 4,4,6),xpd=T) # margin 조정\nbarplot(tab, ylim = c(0,1000))\nlegend(7.5,900, legend=rownames(tab), fill=grey(c(0.3,0.9)), yjust=1)\n\n## 비율계산\ntab_rate <- tab/matrix(1,2,1) %*% apply(tab, 2, sum)\n\nbarplot(tab_rate, names.arg = names(tab_rate), main=\"남/녀 지원자 수 비율\")\nlegend(7.5,1, legend=rownames(tab), fill=grey(c(0.3,0.9)), yjust=1)\n\n## 남자 전체와 여자 전체의 그래프\nbarplot(t(tab), beside = T, main=\"과별 지원한 성별 비교\")\n\n## 합격률 비교\ntab.m <- UCBAdmissions[,1,] # 남자의 합격률\ntab.f <- UCBAdmissions[,2,] # 여자의 합격률\n\napply(tab.m,1,sum)/sum(tab.m)\napply(tab.f,1,sum)/sum(tab.f)\n\ntab.m.c <- tab.m/(matrix(1,2,1) %*% apply(tab.m,2,sum))\ntab.f.c <- tab.m/(matrix(1,2,1) %*% apply(tab.f,2,sum))\n\npar(mfcol=c(1,2))\nbarplot(tab.m.c, main=\"Male\")\nlegend(7.5,1,legend=rownames(tab.m.c), fill=grey(c(0.3,0.9)), yjust=1)\n\nbarplot(tab.f.c, main=\"FeMale\")\nlegend(5,1, legend=rownames(tab.f.c), fill=grey(c(0.3,0.9)), yjust=1)\n\nmosaicplot(~Dept+Gender, data= UCBAdmissions) # 과 안에서 남녀 비율 \nmosaicplot(~Gender+Dept, data= UCBAdmissions) # 성별 안에서 과 비율 확인\nmosaicplot(~Dept+Admit, data=UCBAdmissions) # 과 안에서 합격률 확인\nmosaicplot(~Gender+Dept+Admit, data=UCBAdmissions)  # 성별 중에서 각 과의 합격/불합격 확인\n\n#### sales 구매지역별 대분류 종류 확인(2원빈도표)\n",
    "created" : 1457935547011.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "682959286",
    "id" : "F1019E13",
    "lastKnownWriteTime" : 1458549390,
    "path" : "C:/EDA/week2/week2_EDA.R",
    "project_path" : "week2_EDA.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}