{
    "contents" : "library(dplyr)\n### data loading -----\ncustomerDb <- read.csv(\"customerDb.csv\", stringsAsFactors=F)\nhead(customerDb)\nbasketData <- read.csv(\"basketData.csv\", stringsAsFactors=F)\nhead(basketData)\nstr(basketData)\n\n\n\n### 기본 EDA--------------\n\n#1. 가장 소비를 많이하는 고객Id는?\ncostcust <- group_by(basketCustom, custId)\nhead(costcust)\n\nloyalCustomer <- summarize(costcust, sumAmount = sum(amount))\nloyalCustomer <- arrange(loyalCustomer, desc(sumAmount))\n\nhead(loyalCustomer)\n#2. 가장 매출이 많은 branch는?\nhead(basketDb)\nbranchData <- group_by(basketData, branchId)\n\nloyalBranch <- summarize(branchData, sumAmount = sum(amount))\nloyalBranch <- arrange(loyalBranch, desc(sumAmount))\nhead(loyalBranch)\n\n## RFM 분석--------\n\n# RFM 분석이 무엇인지는 알고 계신가요?\n## Recency- 거래의 최근성: 고객이 얼마나 최근에 구입했는가?\n## Frequency- 거래빈도: 고객이 얼마나 빈번하게 우리 상품을 구입했나?\n## Monetary- 거래규모: 고객이 구입했던 총 금액은 어느 정도인가?.\n\n\nhead(basketData)\nhead(customerDb)\n# date 형으로 변환\nbasketData$date <- as.Date(as.character(basketData$date), format=\"%Y%m%d\")\n# 크기를 비교하기위해 다시 숫자형태로\nbasketData$date <- as.numeric(basketData$date)\n\nbasketCustom <- left_join(basketData, customerDb)\n##RFM의 의미 이해 필요\nlibrary(dplyr)\n\n# basketData를 custId와 date별로 데이터를 뽑아.\ngroupbyDummy <- group_by(basketCustom, custId, date)\nhead(groupbyDummy)\n\n## 날짜별 사용자 현황\nuserFreq <- summarize(groupbyDummy, N=n())\nuserFreq\n\n## 고객별 마트이용횟수\nuserF <- summarize(userFreq,frequency=n())\nuserF\n\n## basketData를 custId별로 데이터를뽑아\ngroupbyDummy <- group_by(basketCustom, custId)  \nhead(groupbyDummy)\n\n## 마트사용량을 date기간별로 나타내라.\nuserRFM <- summarize(groupbyDummy, minRecency=min(date),\n                             recency=max(date),\n                             monetary=sum(amount),\n                             period=max(date)-min(date))\nuserRFM\nuserRFM <- left_join(userRFM, userF)\n\n\n\nhead(userRFM);tail(userRFM)\n\n## 마트사용금액합계로 내림차순..\narrange(userRFM, desc(monetary))\n\n## Chain rule 연습------\nhead(basketData)\nunique(basketData$branchId)\nfilterDummy <- filter(basketData, branchId == \"branch_01\")\ngroupbyDummy <- group_by(filterDummy, custId, date)\nsummarizeDummy <- summarize(groupbyDummy, frequency=n(), monetary=sum(amount))\nsummarizeDummy\nfrequencyDummy <- summarize(summarizeDummy, frequency=n())\nfrequencyDummy\n\nbasketData %>% \n  filter(branchId == \"branch_01\") %>%\n  group_by(custId, date) %>%\n  summarize(frequency=n(), monetary=sum(amount)) %>%\n  summarize(frequency=n())\n\nfrequencyDummy <- basketData %>% \n  filter(branchId == \"branch_02\") %>%\n  group_by(custId, date) %>%\n  summarize(frequency=n(), monetary=sum(amount)) %>%\n  summarize(frequency=n())\nfrequencyDummy\n\n\n##RFM연습 다시 시작-------\nuserRFM$minDate <- as.Date(userRFM$minRecency, origin=\"1970-01-01\")\nuserRFM$maxDate <- as.Date(userRFM$recency, origin=\"1970-01-01\")\n\n## 히스토그램\nhist(userRFM$maxDate, breaks=10)\n\nstr(userRFM)\nlength(unique(userRFM$maxDate))\nhist(userRFM$monetary, breaks=100)\nrange(userRFM$monetary)\n\n## 마트를 가장많이 사용하는 날짜\nplot(table(userRFM$maxDate), main=\"Guests Recency\")\n\n## 마트를 사용하는 손님 빈도수\nplot(table(userRFM$frequency), main=\"Guests Frequency\")\n\n\n# 분위수를 따로 구한다.\nquantile(userRFM$monetary, c(0.2,0.4,0.6,0.8))\n\nquantile(as.numeric(userRFM$maxDate), c(0.2,0.4,0.6,0.8,0.9)) # 날짜를 numeric으로 바꾸면 분위수 계산이 가능해 진다.\n\n# RFM별로 상위 20%가 차지하는 총 매출액 대비 비중을 구한다.\nsumM <- sum(userRFM$monetary[userRFM$monetary > quantile(userRFM$monetary, 0.8)])\nsumM/sum(userRFM$monetary) # 65%로 가장 크다.\n\n## 빈도수\nsumF <- sum(userRFM$monetary[userRFM$frequency > quantile(userRFM$frequency, 0.8)])\nsumF/sum(userRFM$monetary) # 58%로 중간 수준이다.\n\nas.Date(quantile(userRFM$recency,0.8), origin=\"1970-01-01\")\nhead(as.numeric(userRFM$maxDate))\nstr(userRFM)\n\nsumR <- sum(userRFM$monetary[userRFM$recency > quantile(userRFM$recency, 0.8)])\nsumR/sum(userRFM$monetary) # 43%로 가장 적다.\n\nweightR <- sumR/(sumR + sumF + sumM)\nweightF <- sumF/(sumR + sumF + sumM)\nweightM <- sumM/(sumR + sumF + sumM)\n\n# RFM지수 = weightR * Recency 점수 + weightF * Frequency점수 + weightM * Monetary 점수\nquantM <- quantile(userRFM$monetary,c(0,0.2,0.4,0.6,0.8,1))\nlength(quantM)\nquantM\nquantR <- as.Date(quantile(as.numeric(userRFM$maxDate),c(0,0.2,0.4,0.6,0.8,1)),origin=\"1970-01-01\")\nquantR\nquantF <- quantile(userRFM$frequency,c(0,0.2,0.4,0.6,0.8,1))\nquantF\n\n\n\n# parse 함수 활용방법\ncolumnName <- paste0(\"userRFM\",\"$\",\"frequency\")\neval(parse(text=columnName))[2] # 문자열 조합으로 데이터프레임의 열을 찾는 방법\n# ?parse\n\n\nhead(userRFM$frequency)\n\n\nintervalGrade <- function(mainData, fileName, rfmName, quantileData) {\n  \n  forLength <- dim(mainData)[1]\n  \n  results <- rep(0, forLength)\n  \n  \n  for (i in 1:forLength) {\n    \n    data <- eval(parse(text=paste0(fileName,\"$\",rfmName)))[i]\n    \n    if (data >= quantileData[1] && data < quantileData[2] ) {\n      results[i] <- 1\n    } else if (data >= quantileData[2] && data < quantileData[3]) {\n      results[i] <- 2\n    } else if (data >= quantileData[3] && data < quantileData[4]) {\n      results[i] <- 3\n    } else if (data >= quantileData[4] && data < quantileData[5]) {\n      results[i] <- 4\n    } else { results[i] <- 5 }\n  }\n  \n  return(results)\n}\n\n\nuserRFM$R <- intervalGrade(userRFM, \"userRFM\", \"maxDate\", quantR )\nuserRFM$F <- intervalGrade(userRFM, \"userRFM\", \"frequency\", quantF )\nuserRFM$M <- intervalGrade(userRFM, \"userRFM\", \"monetary\", quantM )\n\nhead(userRFM)\n\nuserRFM$score <- (weightR * userRFM$R + weightF * userRFM$F + weightM * userRFM$M)*100/5\n\nhist(userRFM$score)\n\n\ndim(userRFM)\n\n(quantS <- quantile(userRFM$score,c(0,0.2,0.4,0.6,0.8,1)))\n\nfinalGrade <- function(mainData, fileName, rfmName, quantileData) {\n  \n  forLength <- dim(mainData)[1]\n  \n  results <- rep(0, forLength)\n  \n  \n  for (i in 1:forLength) {\n    \n    data <- eval(parse(text=paste0(fileName,\"$\",rfmName)))[i]\n    \n    if (data >= quantileData[1] && data < quantileData[2] ) {\n      results[i] <- \"E\"\n    } else if (data >= quantileData[2] && data < quantileData[3]) {\n      results[i] <- \"D\"\n    } else if (data >= quantileData[3] && data < quantileData[4]) {\n      results[i] <- \"C\"\n    } else if (data >= quantileData[4] && data < quantileData[5]) {\n      results[i] <- \"B\"\n    } else { results[i] <- \"A\" }\n  }\n  \n  return(results)\n}\n\nlibrary(dplyr)\nuserRFM$grade <- finalGrade(userRFM, \"userRFM\", \"score\", quantS )\nhead(as.data.frame(userRFM)),\nstr(userRFM)\n\nuserRFM <- left_join(userRFM, customerDb)\nuserRFM <- arrange(userRFM, desc(score))\nuserRFM <- left_join(userRFM, basketData)\n\ninstall.packages(\"sqldf\")\nlibrary(sqldf)\n\ngetData <- sqldf(\"select custId,minRecency,recency,monetary,period,frequency,minDate, maxDate, score, sex, age, city,branchId,category,division  from userRFM\")\n\nsummaryByCategory <-  summarize(getData, category = count(category))\n\n\n",
    "created" : 1432436743538.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4184189253",
    "id" : "F28DF72E",
    "lastKnownWriteTime" : 1432345179,
    "path" : "~/R/20150516_R/20150515_Week11_lec.R",
    "project_path" : "20150515_Week11_lec.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}