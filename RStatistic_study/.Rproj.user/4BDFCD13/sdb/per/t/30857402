{
    "contents" : "---\ntitle: \"데이터 처리 및 가공 패키지\"\noutput: html_document\n---\n\nsqldf 패키지 ; SQL문을 통해 data.frame을 조회하는 패키지\n\n```{r, echo=FALSE}\n# install.packages(\"sqldf\")\nlibrary(sqldf)\n\n```\niris 테이블을 조회.\n```{r}\nsqldf(\"SELECT distinct Species FROM iris\")\n```\n\nsetosa에 속하는 데이터에서 Sepal.Length의 평균 조회\n주의사항은 SQL에서 \".\"은 테이블의 컬럼이 될 수 없기 때문에 \"_\"로 대신써서 조회\n```{r}\n\nsqldf('select avg(\"Sepal.Length\") from iris where Species=\"setosa\"')\n\n```\n\n위의 조회값을 R의 기본함수를 쓸 경우 \n```{r}\nmean(subset(iris, Species == \"setosa\")$Sepal.Length)\n```\n\n종별 Sepal.Length의 평균 \n```{r}\nsqldf('select avg(\"Sepal.Length\") from iris group by \"Species\"')\n```\n\n```{r, echo=FALSE}\nhead(sapply(split(iris$Sepal.Length, iris$Species), mean))\n```\n\n\n위의 조회값을 R의 기본함수로 쓸 경우\n이와 같이 R코드를 모를 경우 sqldf는 쉽게 사용할 수 있다\n\nsqldf 는 오로지 조회용으로만 사용 된다는 점 알아두자.\n```{r}\n\nsqldf('insert into iris values (1.0,2.0,2.0,2.0, \"setosa\")')\n\n```\n\n분할 적용, 재조합을 통한 데이터 분석\n```{r}\n# install.packages(\"plyr\")\nlibrary(plyr)\n\n```\n\n1) adply() : 배열(a)을 받아 데이터 프레임(d)를 반환하는 함수\n             입력데이터가 행렬처럼 다룰 수 있는 형태의 데이터 인가가 중요\n             \n   vs apply() : apply()의 경우 행방향 처리 시 각 컬럼의 데이터 타입이 다르면 예상치 못한 값으로 반환한다.\n\n행이 같은 타입을 가진 경우는 문제 없음.\n```{r}\nhead(apply(iris[,1:4] , \n            1,\n            function(row) { print(row)}))\n```\n\n행이 서로 다른 타입을 가진 경우는 예상치 못한 형변환이 발생\n```{r}\nhead(apply(iris,\n        1,\n        function(row) { print(row)}))\n```\n\nadply는 변수의 형변환이 발생하지 않는다.\n```{r}\nhead(adply(iris, \n      1, \n      function(row) { row$Sepal.Length >= 5.0 & \n          row$Species == \"setosa\"}))\n```\n\n\n```{r}\nhead(adply(iris,\n        1,\n        function(row) {\n          data.frame(sepal_ge_5_setosa = c(row$Sepal.Length >= 5.0 &\n                                              row$Species == \"setosa\"))\n        }))\n\n\nhead(adply(iris,\n        1,\n        function(row) {\n          if (row$Sepal.Width >= 3.5) {\n                a = \"A\"         \n          }else {\n                a = \"B\"         \n          }\n          data.frame(sepal_ge_5_setosa = \n                       a)\n        }))\nhead(iris)\n```\n\n2) ddply() : 데이터프레임(d)을 입력받아 데이터프레임(d)로 내보내는 함수\n```{r}\nhead(ddply(iris,\n      .(Species),\n      function(sub) {\n        data.frame(sepal.width.mean = mean(sub$Sepal.Width))\n      }))\n```\n\nadply()와 같이 data.frame형태로 반환 안할 경우 임의 컬럼값 V1이 들어감.\n```{r}\nhead(ddply(iris,\n      .(Species),\n      function(sub) {\n        mean(sub$Sepal.Width)\n      }))\n```\n\n여러 변수를 그룹화 하고자 한다면\n```{r}\nhead(ddply(iris,\n        .(Species, Sepal.Length > 5.0),\n      function(sub) {\n        data.frame(sepal.width.mean = mean(sub$Sepal.Width))\n      }))\n```\n\n3) mdply()\n```{r}\n(x<- data.frame(mean=1:5, sd=1:5))\nmdply(x, rnorm, n=2)\n\n```\n그룹마다 연산을 쉽게 수행하기\n1) transform() : 변환할 객체에 대한 데이터 프레임을 반환 \n```{r}\nhead(ddply(baseball, .(id), transform, cyear = year - min(year) + 1))\n\n```\n\n2) mutate() : 데이터 프레임에 새로운 컬럼을 추가하거나 기존 컬럼을 수정(여러개 추가 가능)\n```{r}\nhead(ddply(baseball, .(id), mutate, cyear = year - min(year)+1, log_cyear = log(cyear)))\n```\n\nmutate 는 아래 처럼도 표현 가능(단, 아래처럼 할 경우 한 컬럼씩만 추가)\n```{r}\nbaseball$cyear = baseball$year - min(baseball$year)+1\n```\n3) summarise() : 데이터 프레임을 요약한다.\n```{r}\nhead(ddply(baseball, .(id), summarise, minyear = min(year)))\n```\n\n아래 처럼 group_by() 후 summarise() 사용도 가능\n```{r}\n# install.packages(\"dplyr\")\nlibrary(dplyr)\nbaseball_grp <- group_by(baseball, id) ## group_by 로 id 지정 후\nhead(summarise(baseball_grp, minyear = min(year))) ## summarise 활용 가능\nhead(summarize(baseball_grp, minyear = min(year))) ## summarize도 같은 기능을 수행함\n```\n4) subset() : 벡터,행렬, 데이터 프레임의 일부를 반환한다.\n```{r}\nhead(ddply(baseball, .(id), subset, g==max(g)))\n```\n\n데이터 구조의 변형과 요약\n\n```{r}\n# install.packages(\"reshape2\")\nlibrary(reshape2)\n```\n\n1) melt() : 식별자id, 측정변수variable, 측정치value 형태로 데이터를 재구성하는 함수\n```{r}\nhead(french_fries)\nm <- melt(french_fries, id.vars = 1:4)\nhead(m)\nwhich(is.na(m) == TRUE)\n\nx <- c(1,2,3,4)\n\nmean(x)\n\nx <- c(1,2,NA,3)\nsum(x)\nmean(x, na.rm = TRUE)\n```\nmelt를 쓰게 되면 variable 마다 그룹 지어 통계치를 계산하는 작업이 간단해진다.\n```{r}\nhead(ddply(m, .(variable), summarise, mean = mean(value, na.rm=TRUE)))\n```\n\n위에서 na.rm=TRUE 결과는 melt결과로 인해 value가 NA 값이 필요해서 쓴 값이다.\nNA를 포함한 행을 확인하는 건 complete.cases()\n```{r}\nhead(french_fries[!complete.cases(french_fries), ])\n```\n\nNA를 포함한 측청치를 melt단계 서부터 제거하려면\n```{r}\nm <- melt(id=1:4, french_fries, na.rm=TRUE)\nhead(m)\n```\n\n2) cast() : melt된 데이터를 다시 컬럼으로 변환. 얻고자하는 데이터 타입에 따라 dcast(), acast()로 구분\n\nfrench_fries데이터를 melt() 후 dcast()로 원데이터로 변환하는 예제\n```{r}\nm <- melt(french_fries, id.vars=1:4)\nhead(m)\nr <- dcast(m, time+treatment+subject+rep ~ ...)\nhead(r)\nrownames(r) <- NULL\nrownames(french_fries) <- NULL\nidentical(r, french_fries)\n```\n\ndast() 시 time만 포뮬러에서 ~ 왼쪽에 적고 측정 변수를 오른쪽에 적은 예\n```{r}\nm <- melt(french_fries, id.vars=1:4)\nhead(dcast(m, time~variable))\n```\n\n```{r}\nhead(dcast(m, time~variable, mean, na.rm=TRUE))\n```\ndcast 호출 시포뮬러 ~ 우측은 측정 변수를 적는 곳, 측정변수는 결과에서 새로운 컬럼이 됨.\n```{r}\nhead(dcast(m, time~treatment+variable, mean, na.rm = TRUE))\n```\n\n5. 데이터 테이블 : 더 빠르고 편리한 데이터 프레임, 데이터 프레임 대신 사용이 가능하다.\n   장점 : 빠른속도, 연산의 편의성\n```{r}\n# install.packages(\"data.table\")\nlibrary(data.table)\nclass(data.table())\n```\n\n```{r}\niris_table <- as.data.table(iris)\nx <- data.table(x=c(1,2,3), y=c(\"a\",\"b\",\"c\"))\ntables()\n```\n\n데이터 접근과 그룹 연산 \n```{r}\nDT <- as.data.table(iris)\nDT[1,]\nDT[DT$Species == \"setosa\",]\nDT[1, Sepal.Length]\nDT[1, list(Sepal.Length, Species)]\nDT[, mean(Sepal.Length)]\nDT[, mean(Sepal.Length - Sepal.Width)]\n```\n\n두번째 인자로 컬럼명을 담은 문자열이나 컬럼 번호를 지정하고자 한다면 with=FALSE 옵션 사용\n```{r}\niris_table[1,1,with=FALSE]\n\niris_table[1,1]\n\n```\n\n세번째 인자는 그룹 지을 변수를 지정 \n```{r}\nDT[, mean(Sepal.Length), by=\"Species\"]\n```\n\n변수가 여러개면 by로 나열가능\n```{r}\nDT <- data.table(x=c(1,2,3,4,5), y=c(\"a\",\"a\",\"a\",\"b\",\"b\"), z=c(\"c\",\"c\",\"d\",\"d\",\"d\"))\nDT[, mean(x), by=\"y,z\"]\n```\n\nKey를  사용한 빠른 접근\n```{r}\n# LETTERS\nDF <- data.frame(x=runif(260000), y=rep(LETTERS, each=10000))\n\nsystem.time(x <- DF[DF$y == \"C\",])\n```\n\ny값에 색인을 생성해 검색 시 이용\n```{r}\n\nrequire(data.table)\nDT <- as.data.table(DF)\n\nsetkey(DT,y)\nDT[1,y]\nsystem.time(x <- DT[J(\"C\"), ])\nDT[J(\"C\"), list(x_mean = mean(x), x_std = sd(x))]\n```\n\nkey를 사용한 데이터 테이블 병합\n```{r}\nDT1 <- data.table(x=runif(260000), y=rep(LETTERS, each=10000))\nDT2 <- data.table(y=c(\"A\",\"B\",\"C\"), z=c(\"a\",\"b\",\"c\"))\n\nsetkey(DT1,y)\nnrow(DT1[DT2, ])\n\nsetkey(DT2, y)\nnrow(DT2[DT1,])\n\n```\n\nvs merge() 와의 속도 차이\n```{r}\nsystem.time(DT1[DT2,])\n\nDF1 <- as.data.frame(DT1)\nDF2 <- as.data.frame(DT2)\nsystem.time(merge(DF1, DF2))\n```\n\n참조를 사용한 데이터 수정\n책은 속도가 빠르다 했으나 실행시 그렇지 않음..\n```{r}\nm <- matrix(1, nrow=1000, ncol=100)\nDF <- as.data.frame(m)\nhead(DF)\nDT <- as.data.table(m)\nhead(DT)\n\nsystem.time({\n  for (i in 1:1000) {\n    DF[i,1] <- i\n  }\n})\n\nsystem.time({\n  for (i in 1:1000) {\n    DT[i, V1 := i]\n  }\n})\n```\n리스트를 데이터 프레임으로 변환하기\nldply()와 llply()의 성능 비교\n```{r}\nlibrary(plyr)\nsystem.time(x <- ldply(1:10000, function(x) {\n  data.frame(val = x, val2 = 2*x, val3 = 2 / x, val4 = 4*x, val5 = 4/x)\n}))\n\nsystem.time(x <- llply(1:10000, function(x) {\n  data.frame(val = x, val2 = 2*x, val3 = 2 / x, val4 = 4*x, val5 = 4/x)\n}))\n```\n\n데이터 프레임으로 합치기\n```{r}\nx<- lapply(1:1000, function(x) {\n  data.frame(val=x, val2=2*x, val3=2/x, val4=4*x, val5=4/x)\n})\n\n\nsystem.time(y <- do.call(rbind, x)) ## 여러개의 data.frame을 합칠때 사용\n\n```\n\n위와같이 시간이 걸리기 때문에 rbindlist를 통해 시간단축 가능\n```{r}\nsystem.time(x <- ldply(1:10000, function(x) {  ## list를 data.frame으로 \n  data.frame(val = x, val2 = 2*x, val3 = 2 / x, val4 = 4*x, val5 = 4/x)\n})) \n\nsystem.time(x <- llply(1:10000, function(x) { ## 1.우선 list화 시킴\n  data.frame(val = x, val2 = 2*x, val3 = 2 / x, val4 = 4*x, val5 = 4/x)\n}))\n\nsystem.time(x <- rbindlist(x))  ## 2. 그 결과를 다시 data.table로 변경\n```\n\n더 나은 반목문\n```{r}\n# install.packages(\"foreach\")\nlibrary(foreach)\n```\n\n```{r}\nforeach(i=1:5) %do% { ## combine 미 지정 시 list로 출력\n  return (i)\n}\n```\n```{r}\nforeach(i=1:5, .combine=c) %do% { ## vector로 출력\n  return (i)\n}\n```\n```{r}\nforeach(i=1:5, .combine=rbind) %do% { ## rbind 즉 세로형태로 출력\n  return (i)\n}\n\nforeach(i=1:5, .combine=cbind) %do% { ## cbind 즉 가로형태로 출력\n  return (i)\n}\n\nforeach(i=1:10, .combine=\"+\") %do% {  ## 사칙연산도 가능\n  return(i)\n}\n```\n\n병렬처리 : window의 경우 doParallel 사용\n```{r}\n# install.packages(\"doParallel\")\nlibrary(doParallel)\n```\n프로세스 수 설정\n```{r}\nregisterDoParallel(cores=4)\n```\nplyr의 병렬화 : .parallel 옵션을 TRUE로 지정하여 병렬처리 \n```{r}\n\nbig_data <- data.frame(\n  value = runif(NROW(LETTERS) * 200000),\n  group = rep(LETTERS, 200000))\n\n# dlply(big_data, .(group), function(x) {\n#   mean(x$value)\n# }, .parallel = TRUE)\n```\n\nforeach의 병렬화 : %do% 대신 %dopar%로 지정\n```{r}\nbig_data <- data.frame(\n  value = runif(NROW(LETTERS) * 200000),\n  group = rep(LETTERS, 200000))\n\nforeach(i = 1:10000) %dopar% {\n  mean(big_data$value + i)\n}\n```\n\n유닛테스트와 디버깅\n```{r}\n# install.packages(\"testthat\")\nlibrary(testthat)\n```\n```{r}\na <- 1:3\na\nb <- 1:3\nb\nexpect_equal(a,b) # 문제없음\nexpect_equivalent(a,b)\n\nnames(a) <- c('a','b','c') # a vector에 이름부여\na\nb\n# expect_equal(a,b) # vector들 간의 이름,값 확인\nexpect_equivalent(a,b) # vector들 간의 값만 확인\n```\n\n```{r}\nfib <- function(n) {\n  if (n==0) {\n    return(1)\n  }\n  if (n < 0) {\n    return (fib(n-1) + fib(n-2))\n  }\n}\n\nexpect_equal(1,fib(0)) # 성공\nexpect_equal(1,fib(1)) # 에러\n\n```\n\n테스트 그룹화 : test_that\n```{r}\ntest_that(\"base case\", {\n  expect_equal(1, fib(0))\n  # expect_equal(1, fib(1))\n})\n```\n\n```{r}\nfib <- function(n) {\n  if (n==0 || n==1) {\n    return(1)\n  }\n  if (n >=2) {\n    return (fib(n-1) + fib(n-2))\n  }\n}\n\ntest_that(\"base test\", {\n  expect_equal(1, fib(0))\n  expect_equal(1, fib(1))\n})\n\ntest_that(\"recursion test\", {\n  expect_equal(2, fib(2))\n  expect_equal(3, fib(3))\n  expect_equal(5, fib(4))\n})\n\n```\n\n테스트위한 소스실행\n```{r}\n# source(\"run_tests.R\")\n```\n\n디버깅 위한 방법\n\n1) print()\n```{r}\nfibo <- function(n) {\n  if (n==1 || n==2) {\n    print(\"base case\") ## 이부분을 호출하는지 확인\n    return(1)\n  }\n  \n  print(paste0(\"fibo(\", n-1, \")+fibo(\", n-2, \")\"))  ## 이부분을 호출하는지 확인\n  return(fibo(n-1) + fibo(n-2))\n}\n\nfibo(1)\nfibo(2)\nfibo(3)\n```\n2) sprintf() : 주어진 규칙에 맞게 문자열 반환\n```{r}\nsprintf(\"%d\", 123)\nsprintf(\"Number : %d \", 123)\nsprintf(\"Number : %d, Sring : %s\", 123, \"hello\")\nsprintf(\"%.2f\", 123.456)\nsprintf(\"%5d\", 123)\nsprintf(\"%5d\", 1234)\n```\n3) cat() : 내용 출력 후 줄바꿈이 일어나지 않음\n```{r}\nprint(\"hi\"); print(\"hello\")\ncat(\"hi\");cat(\"hello\")\ncat(\"hi\\n\");cat(\"hello\")\n\nsum_to_ten <- function() {\n  sum <- 0\n  cat(\"Adding ...\")\n  for (i in 1:10) {\n    sum <- sum+i\n    cat(i, \"...\")\n  }\n  cat(\"Done!\", \"\\n\")\n  return (sum)\n}\n\nsum_to_ten()\n```\n\n4) browser() : 호출된 시점부터 수행 중지 후 디버깅 모드 시작\n```{r}\nsum_to_ten_browser <- function() {\n  sum <- 0\n  \n  for (i in 1:10) {\n    sum <- sum+i\n    if (i >= 5) {\n      browser()\n    }\n  }\n  return (sum)\n}\n\nsum_to_ten_browser()\n```\n\n코드 프로파일링 : 메모리나 CPU사용량 평가\n```{r}\nadd_one <- function(val) {\n  return (val+1)\n}\n\nadd_one_to_vec <- function(x) {\n  for (i in seq_along(x)) {\n    x[i] <- add_one(x[i])\n  }\n  return (x)\n}\n\n# Rprof(\"add_one.out\")  ## 프로파일링 열기\nx <- add_one_to_vec(1:100000)\nhead(x)\n# Rprof(NULL)          ## 프로파일링 닫기\n# summaryRprof(\"add_one.out\")\n```",
    "created" : 1454050541503.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2063200144",
    "id" : "30857402",
    "lastKnownWriteTime" : 1454143178,
    "path" : "C:/RCodeRepositories/RStatistic_study/chapter5.Rmd",
    "project_path" : "chapter5.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}