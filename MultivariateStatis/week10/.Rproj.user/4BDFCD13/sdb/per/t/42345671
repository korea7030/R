{
    "contents" : "library(MVA)\n\nus2 = scale(USArrests)\nstr(us2)\n## data frame으로 변환\nus2 = data.frame(us2)\n\nkm = kmeans(us2,3)\nkm\n# K-means clustering with 3 clusters of sizes 20, 17, 13  (Initial을 Random 하게 잡아줌)\n# \n# Cluster means: (군집된 공간에서의 중심점)\n#   Murder    Assault   UrbanPop       Rape\n# 1  1.0049340  1.0138274  0.1975853  0.8469650\n# 2 -0.4469795 -0.3465138  0.4788049 -0.2571398\n# 3 -0.9615407 -1.1066010 -0.9301069 -0.9667633\n# \n# Clustering vector: (각 관측치가 어떤 그룹으로 할당되었는지를 나타냄)\n#   Alabama         Alaska        Arizona       Arkansas     California       Colorado \n# 1              1              1              2              1              1 \n# Connecticut       Delaware        Florida        Georgia         Hawaii          Idaho \n# 2              2              1              1              2              3 \n# Illinois        Indiana           Iowa         Kansas       Kentucky      Louisiana \n# 1              2              3              2              3              1 \n# Maine       Maryland  Massachusetts       Michigan      Minnesota    Mississippi \n# 3              1              2              1              3              1 \n# Missouri        Montana       Nebraska         Nevada  New Hampshire     New Jersey \n# 1              3              3              1              3              2 \n# New Mexico       New York North Carolina   North Dakota           Ohio       Oklahoma \n# 1              1              1              3              2              2 \n# Oregon   Pennsylvania   Rhode Island South Carolina   South Dakota      Tennessee \n# 2              2              2              1              3              1 \n# Texas           Utah        Vermont       Virginia     Washington  West Virginia \n# 1              2              3              2              2              3 \n# Wisconsin        Wyoming \n# 3              2 \n# \n# Within cluster sum of squares by cluster: \n# (각각 3가지의 값이 나타내는게 각 군집 중심에서 관측치까지 나온 거리의 제곱의 합)\n#   [1] 46.74796 19.62285 11.95246\n# (between_SS / total_SS =  60.0 %)\n# \n# Available components:\n#   \n#   [1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\" \"betweenss\"   \n# [7] \"size\"         \"iter\"         \"ifault\"\n\nkm$cluster  ## 클러스터가 할당된 결과\n\nplot(Murder~Rape, data=us2, pch=km$cluster, col= km$cluster)\ntext(us2$Rape, us2$Murder, rownames(us2), cex=0.8, col=km$cluster)\n\n##### 각 클러스터가 어떤식으로 나타나는지 확인\n\n## 그리는 개수를 3행으로 표시\npar(mfcol=c(3,1))\n\n## y축의 scale을 맞춤\nfor (i in 1:3) {\n  boxplot(us2[km$cluster == i,], main=paste(\"Group\", i), ylim=c(-2.5, 3))\n  abline(0,0,lty=2)  ## y=a+bx 의 선을 그어줌(a=0, b=0)\n}\n## 0을 기준으로 밑에 있으면 평균이하를 나타냄.\n\n## ESS 계산\n\n\nESS = c()\nfor (k in 1:10) {\n  km = kmeans(us2,k)\n  ESS[k] = sum(km$withinss)\n}\n\nplot(ESS, type=\"l\")\n\n# [1] 46.74796 19.62285 11.95246\n## 4개로 군집의 개수를 나눠주면 좋을듯 합니다.\n\n\n# HW4############################################################################################################\n# 22개 미국 전투기에 대한 6개 변수값이 jet.csv에 저장되어 있다. 각 변수는 아래와 같다.\n# -\tFFD: 처음 비행 날짜\n# -\tSPR: 단위무게 당 출력에 비례하는 특정한 출력\n# -\tRGF: 비행범위 요인\n# -\tPLF: 비행기의 총 무게의 일부분으로서의 탑재량\n# -\tSLF: 일관된 무게 요인\n# -\tCAR: 비행기가 항공모함에 착륙 가능여부\n# 1.\t계층적군집분석\n# A.\tFFD와 CAR를 제외한 변수를 표준화(scale) 한 후 최장연결법을 사용해 비계층적 군집화를 시행하고 덴드로그램을 그리시오.\njet_csv = read.csv(\"jet.csv\")\nhead(jet_csv)\nsummary(jet_csv)\njet_csv[,1]\nrow.names(jet_csv) = jet_csv[,1]\njet_csv = jet_csv[,-1]\njet = jet_csv[,-c(1,6)]\njet\nhc = hclust(dist(scale(jet)), method=\"complete\")\nhc\nplot(hc)\n\n# 1. B \n## 군집의 개수 결정(2개의 집단)\ngroups = cutree(hc, k=2)\nrect.hclust(hc, k=2, border=\"red\")\n\n## 군집개수 결과를 groups 라는 변수로 dataframe 추가\n## plot 그릴 때의 숫자값으로 쓰일 예정\njet['groups'] = as.factor(groups)\nhead(jet)\n\nstr(jet)\n\n## 주성분 계산 시에는 빼고 계산 할 것. \n## 위에서 factor로 groups를 생성했기 때문에 계산이 안됨.\njet_pca = prcomp(jet[,-5], scale=TRUE)\njet_pca\n\n## PC1, PC2에 대한 주성분 분석 결과 산점도\nplot(main=\"procomp PC1 & PC2 Plot\", xlab=\"PC1\", ylab=\"PC2\", jet_pca$x[,1], \n     jet_pca$x[,2], col= as.numeric(jet$groups)+1, pch=as.numeric(jet$groups)+1)\ntext(jet_pca$x[,1] , jet_pca$x[,2], rownames(jet), cex=0.5, pos=3)\n\n\n# 2. A\n\n\n\nESS2 = c()\nfor (k in 1:5) {\n  km = kmeans(scale(jet[,-5]),k)  ## 위와 똑같이 groups 값 제외 하고 계산\n  ESS2[k] = sum(km$withinss)\n}\n\nplot(ESS2, type=\"l\")\n\n\n# 2. B \nkm_jet = kmeans(scale(jet[,-5]), 2)  ## 위와 똑같이 groups 값 제외 하고 계산\nkm_jet \nkm_jet$cluster\n\n## 그래프 표시 결과 x축, y축 값이 관측치마다 달라 똑같게 지정 후 그래프 표시\n## 산점도라 했는데, 여쭤보니 변수 적으니 scatter plot으로 그려도 상관없다 하셨음.\npairs(scale(jet[,-5]), pch=km_jet$cluster, col= km_jet$cluster, ylim=c(-2.5, 3), xlim = c(-2.5, 3))\n\n# 3.\njet\njet_mc = Mclust(scale(jet[, -5]))\njet_mc\n\ninstall.packages(\"mclust\")\nlibrary(mclust)\n\nplot(jet_mc)\n# HW4############################################################################################################\n\n## m모형기반 군집분석\n\nus2\nmc= Mclust(us2)\nmc\n# 'Mclust' model object:\n#   best model: diagonal, equal shape (VEI) with 3 components\n## 그룹이 3개 이면서, VEI 형태의 공분산 행렬 형태가 제일 좋은 BIC값이라고 선택된 것을 나타냄. \n\nplot(mc)\n## x축은 그룹의 개수 \n## y축은 BIC값\n## 1번 선택 시(BIC plot)\n## 그룹이 3개면서 VEI가 최대인게 최적의 모양이라고 그래프에 표시됨.\n\n## 2번 선택 시\n## scatter plot 표시\n## 그래프에서의 동그라미는 각 그룹의 정규분포 모양을 나타냄\n#  (중심 : 평균 , 공분산행렬 : 타원형(서로같은 방향)을 나타낸다. \n#  but dimension 간의 분산은 다르고, 그룹간의 분산이 다르다.)\n\n## 3번 선택 시\n## uncertainty(불확실한)\n## 결과가 애매한 거에 대해 그래프를 보여줌(관측치의 모양이 크고 bold체 되어 있는 결과에 대해서)\n\n## 4번 선택 시\n## density\n## 추정된 분포를 나타냄. 등고선형태로 표현\n\nstr(mc)\nmc$classification ## 각 관측치가 어떤 그룹으로 할당 되어있는지\n\n## \n\n## 특정값에 대해 모형분석을 할 경우\nmc2 = Mclust(us2, 4)",
    "created" : 1447476780055.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1442263264",
    "id" : "42345671",
    "lastKnownWriteTime" : 1447561585,
    "path" : "C:/MultivariateStatis/week10/week10.R",
    "project_path" : "week10.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}