{
    "contents" : "getwd()\nsetwd(\"C:/Users/leejh/Documents/20150314_R\")\ngetwd()\n\n##### 20150314 수업진행 #####\n\n# 예약어 확인\n?reserved\n\n/* \n## 예약어 목록\n## if else repeat while function for in next break\n## TRUE FALSE NULL Inf NaN NA NA_integer_ NA_real_ NA_complex_ NA_character_\n*/\n\n### 연산자 - 연습1\n5+3 ## 8 \n10000000 - 99 ## 999901\n10000000 * 10000000 ## 1e+14 \n3^2 ## 9\n3**3 ## 27(세제곱??)\n3%%2 ## 1 (나머지)\n4%%2 ## 0 \n7777777 %/% 3 ## 1(몫)\n7777777 %% 3 ## 1(나머지)\n\n### 논리연산자\n5<7 ##TRUE\n5<5 ## FALSE\n5<= 5 ## TRUE\n5 == 5.0 ## TRUE\n5L == 5.0 ## TRUE(5L : 정수형 5)\n5!= 5 ## FALSE\n!TRUE ## FALSE\n!FALSE ## TRUE\n2>3 | 5>4 ## TRUE\n2>3 & 5>4 ## FALSE\nisTRUE(2>3 & 5>4) ## FALSE\n\n### 연산자 - 연습2\n5^1/5 ## 1 \n5^(1/5) ## 1.37973\nTRUE+TRUE ## 2\nTRUE+FALSE ## 1\n5+3%%2 ## 6\n(5+3)%%2 ## 0 \n!TRUE ## FALSE\n!!TRUE ## TRUE\n\n### 기초 내장함수\nx <- -1\nabs(x)  ## 절대값\nsqrt(16) ## 4 제곱근\nceiling(1.2) ## 올림 2\nfloor(1.2) ## 내림 1 \nexp(2)  ## 지수함수 값(e의 2승)\nround(1.333, 2) ## 반올림 1.33\nlog(3)  ##상용로그 \nlog10(3)\nnchar(\"xxxx\") ## 4 문자열글자수(number of char)\nsubstr(\"XXXXX\", 1,3) ## 문자열 일부 선택, 시작은 1로 시작\npaste(\"x\",\"y\", sep=\"\") ## 단어 붙이기\nis.na(\"x\") ## NA 여부 확인\n\n## 기초 내장함수 -연습 \nabs(-4) + sqrt(100) ## 14 \n10^2; ## 100  \n10^2/5; ## 20\n10^(2/5) ## 2.511886\nround(2.3456789, digit= 2) ## 2.35\nround(2.3456789, dig = 5) ## 2.34568 \nexp(round(2.3456789, 2)) ## \nexp(round(2.3456789, 5)) ## \nnchar(\"uriappa\") ## 7\nmode(nchar(\"urippa\")) ## 해당 내용의 type형식\nfather <- \"uriappa\"; mother <-\"uriumma\"\nsubstr(father, 1,2) ## ur \npaste(father, mother) ## uriappa uriumma sep=\"\" 안하면 한칸 띄워짐\npaste(father, mother, sep= \"   \") ## 간격 지정한 후 붙임\npaste(father, mother, sep=\"\") ## uriappauriumma\npaste0(father, mother) ## uriappauriumma  sep=\"\" 와 같은 말임\n\n## 수식및 내장함수 코딩 연습 \nProb1 <- exp(3) / (1+exp(3)) \nProb2 <- exp(9^(1/5))\nProb3 <- Prob2 / (1+exp(9^(1/5)))\n\n### Vector \n# 같은 자료형의 성분을 일렬로 저장한 객체\n# 숫자 + 문자가 섞이면 문자형으로 바꿔준다. \n\n## Vector 생성 \nx1 <- c(3,6,9) ## Combine 생성\nx2 <- 1:7 ## 1,2,3,4,5,6,7 \nx3 <- c(1,\"two\"); mode(x3); ## 강제 형변환\nx4 <- scan(); ## scan 함수\n1 2 3 4 5 6 7\nstring.Data <- scan(what=character())  ## character로 된 데이터를 scan\nrucy buttler ## read items 2 \n\nstring.Data ## \"rucy\"    \"buttler\"\n(x<- seq(-5, 5, 0.1)) ## sequence(시작값, 끝값, 간격) 출력시 () 묶음\n?seq\nexample(seq) ## seq 예 \n\nprob <- exp(x) / (1+exp(x))\n\nplot(x, prob)  ## 기본 plot 차트\n\nplot(x, prob, type=\"l\") ## 선형(line) plot 차트\n\nx<- seq(from=-5, by=0.1, to=5)\nsigmoid <- exp(x) / (1+exp(x)) \nsigmoid\n\nplot(x, sigmoid)\n## example(plot)\nexample(seq)\n\nx<- 1:4 ## 1 2 3 4\ny <- 5:8 ## 5 6 7 8\nx/y  ## 1/5 2/6 3/7 4/8 \n\nx<- 1:4 ## x[1] = 1 x[2] = 2 ...\ny<- 5:7\nx*y ## 5 12 21 20 에러는 나지만 적은 자리의 vector값의 일부가 반복되어 진다.\n\n### Vector indexing 및 filtering \nidxData <- seq(from =-20, to =20, by=3)\nidxData\nlength(idxData) ## Vector의 길이 \nidxData[3]\nidxData[c(1,5:7)]  ## 1부터 시작해서 5부터 7까지의 위치는 빼고 출력\nidxData <- idxData[c(1:5,7:length(idxData))]\nidxData\nwhich(idxData<0) ## 데이터 중에 0보다 작은 위치(번호)는?\nwhich(idxData %% 2 == 1) ## 나머지가 1이 아닌거\nidxData[which(idxData %% 2 != 1)]  ## 짝수인 것만 구하기 \n\ngenData <- seq(-200 , 150, 3)\nlength(genData)\n\noddGenData <- genData[genData %% 2 == 1] ## 홀수 \nlength(oddGenData)\nsum(oddGenData)\nevenGetData <- genData[which(genData %% 2 == 0)]\nsum(evenGetData)\nchrGenData <- as.character(genData)\nmode(chrGenData)\nnchar3genData <- chrGenData[nchar(chrGenData) == 3]\nlength(nchar3genData)\nsum(nchar(nchar3genData))\n",
    "created" : 1435237510353.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1003785285",
    "id" : "E5980EDD",
    "lastKnownWriteTime" : 1434982446,
    "path" : "C:/RCodeRepositories/RSpclecture1/20150314_R_lecture.R",
    "project_path" : "20150314_R_lecture.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}